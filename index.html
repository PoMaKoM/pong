<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <title>Ping-Pong</title>
    <style>
      :root {
        --bg: #0f1724;
        --muted: #98a0b3;
        --accent: #06b6d4
      }
      html, body {
        height: 100%;
        margin: 0;
        font-family: Inter, system-ui, Segoe UI, Roboto, Arial
      }
      body {
        background: linear-gradient(180deg, #071126, #07101a);
        color: #e6eef8;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px
      }
      .card {
        width: 920px;
        max-width: 100%;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6);
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.03);
        position: relative
      }
      .header {
        padding: 12px 14px;
        display: flex;
        gap: 12px;
        align-items: center;
        justify-content: space-between;
      }
      .title h1 {
        margin: 10px;
        font-size: 16px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis
      }
      .controls {
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: wrap
      }
      .controls .btn {
        flex-shrink: 0
      }
      .btn {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.06);
        color: inherit;
        padding: 8px 12px;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer
      }

      .canvas-wrap {
        padding: 12px;
        display: flex;
        align-items: center;
        justify-content: center
      }
      #field {
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.005));
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.03);
        box-shadow: inset 0 -8px 30px rgba(2, 6, 23, 0.5);
        max-width: 100%;
        height: auto
      }

      .latency-bar {
        margin: 12px auto 16px;
        padding: 10px 16px;
        border-radius: 999px;
        font-weight: 700;
        font-size: 16px;
        color: #fff;
        min-width: 130px;
        text-align: center;
        background: rgba(255, 255, 255, 0.03);
        display: block;
        width: fit-content
      }
      .lat-label {
        display: block;
        font-size: 12px;
        color: var(--muted);
        font-weight: 500
      }


      /* toggle switch */
      .toggle-wrap {
        display: flex;
        align-items: center;
        gap: 8px
      }
      .toggle {
        position: relative;
        width: 44px;
        height: 26px;
        display: inline-block
      }
      .toggle input {
        opacity: 0;
        width: 0;
        height: 0;
        position: absolute
      }
      .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.06);
        border-radius: 999px;
        transition: 0.22s cubic-bezier(.2, .9, .3, 1);
        border: 1px solid rgba(255, 255, 255, 0.06);
        box-shadow: inset 0 -4px 10px rgba(2, 6, 23, 0.4)
      }
      .toggle-slider:before {
        position: absolute;
        content: "";
        height: 20px;
        width: 20px;
        left: 3px;
        top: 3px;
        background: #fff;
        border-radius: 50%;
        transition: 0.22s cubic-bezier(.2, .9, .3, 1);
        box-shadow: 0 6px 18px rgba(6, 22, 40, 0.6)
      }
      .toggle input:focus + .toggle-slider {
        box-shadow: 0 0 0 6px rgba(6, 182, 212, 0.06)
      }
      .toggle input:checked + .toggle-slider {
        background: linear-gradient(90deg, var(--accent), #7c3aed);
        border-color: rgba(255, 255, 255, 0.08)
      }
      .toggle input:checked + .toggle-slider:before {
        transform: translateX(18px)
      }


      /* responsive tweaks */
      @media (max-width: 720px) {
        body {
          padding: 12px
        }
        .card {
          border-radius: 12px
        }
        .header {
          padding: 10px;
          gap: 10px
        }
        .left {
          gap: 8px
        }
        .title h1 {
          font-size: 15px
        }
        .controls {
          width: 100%;
          justify-content: flex-end
        }
        .controls .btn {
          padding: 8px 10px;
          font-size: 14px
        }
        .toggle-wrap {
          margin-left: 6px
        }
        /* make canvas scale to width while preserving aspect ratio */
        .canvas-wrap {
          padding: 10px
        }
        #field {
          width: 100% !important;
          height: auto !important
        }
        /* latency block stays below the canvas on small screens too */
        .latency-bar {
          margin-top: 10px;
          padding: 8px 12px;
          font-size: 15px;
          min-width: 120px
        }
      }
    </style>
  </head>
  <body>
    <div class="card" role="region" aria-label="Проверка доступности сервиса">
      <div class="header">
        <div class="left">
          <div class="title">
            <h1>Ping-Pong</h1>
          </div>
        </div>

        <div class="controls">
          <button class="btn" id="manualBtn">Manual update</button>
          <div class="toggle-wrap" title="Анимация">
            <label class="toggle" aria-hidden>
              <input id="toggle" type="checkbox" checked aria-label="Анимация слайм"/>
              <span class="toggle-slider" aria-hidden></span>
            </label>
          </div>
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="field" width="760" height="360" role="img" aria-label="Анимация слайм-блока и подбрасываемого мяча"></canvas>
      </div>

      <div id="latencyBar" class="latency-bar">
        <span class="lat-label">Latency</span>
        <div id="latencyDisplay">— ms</div>
      </div>
    </div>

    <script>
      // Wrap everything in DOMContentLoaded to avoid null references
      window.addEventListener('DOMContentLoaded', () => {

        // Settings
        let CHECK_URL = '/';
        let INTERVAL_SEC = 5;

        // Canvas
        const canvas = document.getElementById('field');
        const ctx = canvas.getContext('2d');
        const W = canvas.width;
        const H = canvas.height;

        // Slime + ball
        const slime = {
          x: W / 2 - 48,
          y: H - 96,
          size: 96,
          scaleY: 1,
          targetScaleY: 1,
          compressAmt: 0,
          cells: [],
          rows: 6,
          cols: 6,
          wavePhase: 0
        };
        let ball = {
          x: W / 2,
          y: slime.y - 12,
          r: 10,
          vy: 0,
          inAir: false
        };
        const BASE_TOSS_VY = -650;
        const GRAVITY = 1200;
        let lastTime = performance.now();
        let elapsed = 0;
        let running = true;

        // latency display element (guarded)
        const latencyDisplay = document.getElementById('latencyDisplay');
        let lastLatencyMs = 150;

        // init cells
        (function initCells() {
          for (let y = 0; y < slime.rows; y++) {
            slime.cells[y] = [];
            for (let x = 0; x < slime.cols; x++) {
              slime.cells[y][x] = {
                base: Math.random() * 0.16 - 0.08,
                phase: Math.random() * Math.PI * 2,
                speed: 0.8 + Math.random() * 1.2
              };
            }
          }
        })();

        let tossIntervalBase = 1400;
        let lastToss = performance.now();

        function roundRect(ctx, x, y, w, h, r, fill, stroke) {
          if (typeof r === 'undefined') r = 6;
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
          if (fill) ctx.fill();
          if (stroke) ctx.stroke();
        }

        function latencyToFactor(lat) {
          const f = 1.4 - (lat / 1000) * 0.7; return Math.max(0.7, Math.min(1.6, f));
        }

        function drawSlime(s) {
          const px = s.x, py = s.y, sz = s.size, sy = s.scaleY;
          const drawH = sz * sy;
          const topY = py + (sz - drawH);
          const grad = ctx.createLinearGradient(px, topY, px, topY + drawH);
          grad.addColorStop(0, '#9ffba0');
          grad.addColorStop(1, '#4ad63a');
          ctx.save();
          roundRect(ctx, px, topY, sz, drawH, 8, true, false);
          ctx.fillStyle = grad;
          ctx.fill();
          const cellW = sz / slime.cols;
          const cellH = drawH / slime.rows;
          for (let iy = 0; iy < slime.rows; iy++) {
            for (let ix = 0; ix < slime.cols; ix++) {
              const c = slime.cells[iy][ix];
              const t = elapsed * c.speed + c.phase + slime.wavePhase;
              const mod = Math.sin(t) * 0.25 + c.base;
              const r1 = 124, g1 = 252, b1 = 110;
              const r2 = 74, g2 = 214, b2 = 58;
              const mix = 0.5 + mod;
              const R = Math.round(r1 * (1 - mix) + r2 * mix);
              const G = Math.round(g1 * (1 - mix) + g2 * mix);
              const B = Math.round(b1 * (1 - mix) + b2 * mix);
              const cx = px + ix * cellW;
              const cy = topY + iy * cellH;
              ctx.fillStyle = `rgb(${R},${G},${B})`;
              ctx.fillRect(cx + 2, cy + 2, Math.max(2, cellW - 4), Math.max(2, cellH - 4));
            }
          }
          ctx.beginPath();
          ctx.ellipse(px + sz * 0.6, topY + drawH * 0.2, sz * 0.35, drawH * 0.18, -0.2, 0, Math.PI * 2);
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          ctx.fill();
          ctx.restore();
          ctx.fillStyle = 'rgba(0,0,0,0.28)';
          ctx.fillRect(px + 8, py + sz + 6, sz - 16, 6);
        }

        function drawScene() {
          ctx.clearRect(0, 0, W, H);
          ctx.fillStyle = '#071126';
          ctx.fillRect(0, 0, W, H);
          drawSlime(slime);
          ctx.beginPath();
          ctx.fillStyle = '#ffffff';
          ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,0.12)';
          ctx.stroke();
        }

        function updateSlime(dt) {
          slime.wavePhase += dt * 1.2;
          const ease = 1 - Math.pow(0.6, dt * 60);
          slime.scaleY += (slime.targetScaleY - slime.scaleY) * ease;
          slime.compressAmt *= Math.max(0, 1 - dt * 6);
          if (slime.compressAmt > 0.001) {
            const wobble = Math.sin(elapsed * 18) * 0.02 * slime.compressAmt;
            for (let iy = 0; iy < slime.rows; iy++) {
              for (let ix = 0; ix < slime.cols; ix++) {
                slime.cells[iy][ix].base += wobble * (0.5 - Math.abs((ix - slime.cols / 2) / (slime.cols / 2)));
              }
            }
          }
        }

        function updatePhysics(dt) {
          if (!ball.inAir) {
            ball.x = slime.x + slime.size / 2;
            ball.y = slime.y - ball.r - 2;
          } else {
            ball.vy += GRAVITY * dt;
            ball.y += ball.vy * dt;
            const slimeTop = slime.y + (slime.size - slime.size * slime.scaleY);
            if (ball.y + ball.r >= slimeTop && ball.vy > 0) {
              if (ball.x > slime.x && ball.x < slime.x + slime.size) {
                slime.targetScaleY = 0.62;
                slime.compressAmt = 1;
                const depth = Math.min(slime.size, (ball.y + ball.r) - slimeTop);
                const depthFactor = 0.6 + (depth / slime.size) * 0.9;
                const latencyFactor = latencyToFactor(lastLatencyMs);
                const impulse = Math.max(220, 600 * depthFactor * latencyFactor);
                ball.y = slimeTop - ball.r;
                ball.vy = -impulse * (0.9 + Math.random() * 0.25);
                ball.inAir = true;
                setTimeout(() => { slime.targetScaleY = 1; }, 140);
              } else {
                ball.y = slimeTop - ball.r;
                ball.vy = 0;
                ball.inAir = false;
              }
            }
            if (ball.y > H + 100) {
              ball.inAir = false;
              ball.vy = 0;
              ball.x = slime.x + slime.size / 2;
              ball.y = slime.y - ball.r - 2;
            }
          }
        }

        function maybeToss(now) {
          if (!running) return ;
          const jitter = Math.random() * 600 - 300;
          const interval = Math.max(400, tossIntervalBase + jitter);
          if (!ball.inAir && (now - lastToss) > interval) {
            const factor = latencyToFactor(lastLatencyMs);
            const randomMult = 1 + (Math.random() * 0.6 - 0.3);
            const vy = BASE_TOSS_VY * factor * randomMult;
            ball.inAir = true;
            ball.vy = vy;
            lastToss = now;
            slime.targetScaleY = 0.9;
            setTimeout(() => { slime.targetScaleY = 1; }, 90);
          }
        }

        function loop(now) {
          const dt = Math.min(0.032, (now - lastTime) / 1000);
          lastTime = now;
          elapsed += dt;
          maybeToss(now);
          updatePhysics(dt);
          updateSlime(dt);
          drawScene();
          requestAnimationFrame(loop);
        }
        requestAnimationFrame(loop);

        const manualBtn = document.getElementById('manualBtn');
        const toggle = document.getElementById('toggle');
        manualBtn.addEventListener('click', doCheck);
        toggle.addEventListener('change', () => {
          running = toggle.checked;
          if (!running) {
            ball.inAir = false;
            slime.targetScaleY = 1;
            slime.scaleY = 1;
          }
        });

        async function doCheck() {
          const start = performance.now();
          try {
            const resp = await fetch(CHECK_URL, { method: 'GET', cache: 'no-store' });
            const took = Math.round(performance.now() - start);
            lastLatencyMs = took;
            if (latencyDisplay) latencyDisplay.textContent = took + ' ms';
          } catch(e) {
            const took = Math.round(performance.now() - start);
            lastLatencyMs = took;
            if (latencyDisplay) latencyDisplay.textContent = took + ' ms';
          }
        }

        let periodicTimer = setInterval(() => { if (running) doCheck(); }, INTERVAL_SEC * 1000);
        // initial check
        doCheck();
      });
    </script>
  </body>
</html>